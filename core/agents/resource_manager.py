# core/agents/resource_manager.py

import logging
import json
import asyncio
import random
import time
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, Optional, List

from supabase import create_client, Client as SupabaseClient, PostgrestAPIError

import config # Root config file
from core.services.proxy_manager_wrapper import ProxyManagerWrapper
from core.services.fingerprint_generator import FingerprintGenerator
from core.automation.browser_automator_interface import BrowserAutomatorInterface # The crucial interface

logger = logging.getLogger(__name__)

class ResourceManager:
    """
    Manages access to external resources: proxies, API keys (from config/Supabase),
    and orchestrates automated trial account acquisition using an injected BrowserAutomator
    and FingerprintGenerator. Aims for "Level 25" resourcefulness from the start.
    """

    def __init__(
        self,
        llm_client: Optional[Any], # For generating signup details or other AI tasks
        fingerprint_generator: FingerprintGenerator, # REQUIRED
        browser_automator: BrowserAutomatorInterface # REQUIRED
    ):
        self.llm_client = llm_client
        self.proxy_manager = ProxyManagerWrapper()
        self.fingerprint_generator = fingerprint_generator
        self.browser_automator = browser_automator
        self._trial_acquisition_semaphore = asyncio.Semaphore(config.MAX_CONCURRENT_BROWSER_AUTOMATIONS)
        self._active_automations: List[str] = [] # Track active service automation attempts

        self.supabase: Optional[SupabaseClient] = None
        if config.SUPABASE_ENABLED:
            try:
                self.supabase = create_client(config.SUPABASE_URL, config.SUPABASE_KEY)
                logger.info(f"ResourceManager: Supabase client initialized for table '{config.SUPABASE_RESOURCES_TABLE}'.")
            except Exception as e:
                logger.error(f"ResourceManager: Failed to initialize Supabase client: {e}", exc_info=True)
        else:
            logger.warning("ResourceManager: Supabase not configured. Persistence of managed resources is disabled.")

        self.direct_clay_api_key: Optional[str] = config.CLAY_API_KEY
        if self.direct_clay_api_key:
             logger.info("ResourceManager: Direct Clay API Key (from .env) available.")

    async def _generate_signup_details_for_service(self, service_name: str, context_info: Optional[str]=None) -> Dict[str, Any]:
        """Generates plausible signup details, potentially using LLM for variety and realism."""
        timestamp_part = int(time.time()*1000)
        # Base defaults, aiming for plausibility
        details = {
            "email": f"user.{service_name.replace('.', '_')}.{timestamp_part}@temporary-mail.net", # More plausible temp domain
            "password": f"SecurePa$$w{timestamp_part%10000}#",
            "first_name": random.choice(["Alex", "Jordan", "Casey", "Morgan", "Riley", "Devon"]),
            "last_name": random.choice(["Smith", "Jones", "Williams", "Brown", "Davis", "Miller"]),
            "company_name": f"{random.choice(['InnovateNow', 'SynergyTech', 'QuantumLeap', 'NextGen Solutions', 'Apex Digital'])} Ltd."
        }
        if self.llm_client:
            try:
                prompt_parts = [
                    f"Generate highly plausible, unique, and varied user registration details for a new trial account on a service called '{service_name}'.",
                    "The details should appear as if generated by a human for a legitimate, temporary business evaluation use case.",
                    "Include: first_name (common, diverse English name), last_name (common, diverse English name), email (unique, incorporating '{timestamp_part}', using a common but plausible free domain like gmail.com, outlook.com, or a realistic temporary mail domain like mailinator.com, temporary-mail.net), password (strong, 12+ chars, alphanumeric with symbols), company_name (plausible small to medium tech or consulting business name).",
                ]
                if context_info: prompt_parts.append(f"Context for signup: {context_info}")
                prompt_parts.append("Return ONLY a valid JSON object with keys: 'first_name', 'last_name', 'email', 'password', 'company_name'. Ensure email is unique using the timestamp.")
                
                prompt = "\n".join(prompt_parts)
                response_str = await self.llm_client.generate_response(
                    messages=[{"role": "user", "content": prompt}], temperature=0.85, max_tokens=250
                )
                if response_str and '{' in response_str and '}' in response_str: # Basic check for JSON
                    llm_details = json.loads(response_str.strip())
                    required_keys = ['first_name', 'last_name', 'email', 'password', 'company_name']
                    if all(key in llm_details for key in required_keys):
                        # Further validation (e.g., email format) could be added
                        logger.info(f"LLM generated signup details for {service_name}: {llm_details.get('email')}")
                        return llm_details
                    else:
                        logger.warning(f"LLM response for signup details missing keys. Using defaults. Response: {response_str}")
            except json.JSONDecodeError:
                 logger.warning(f"LLM response for signup details was not valid JSON. Using defaults. Response: {response_str}")
            except Exception as e:
                logger.warning(f"LLM failed to generate signup details for {service_name}, using defaults: {e}")
        
        logger.info(f"Using/Generated basic signup details for {service_name}: email={details['email']}")
        return details

    async def _attempt_and_verify_trial_acquisition(
        self,
        service_name: str,
        service_automation_config: Dict[str, Any] # Contains signup_url, form_plan, success_indicator, extraction_rules, verification_step
    ) -> Optional[Dict[str, Any]]:
        """
        Orchestrates automated trial acquisition AND verification using the BrowserAutomator.
        """
        service_name_lower = service_name.lower()
        if service_name_lower in self._active_automations:
            logger.warning(f"Trial acquisition for '{service_name_lower}' is already in progress. Skipping new attempt.")
            return None
        
        self._active_automations.append(service_name_lower)

        async with self._trial_acquisition_semaphore:
            logger.info(f"Attempting trial acquisition & verification for: {service_name} using URL: {service_automation_config.get('signup_url')}")

            proxy_string = self.get_proxy_string()
            fingerprint = await self.fingerprint_generator.generate_profile(
                role_context=f"Automated trial signup for {service_name}"
            )
            signup_details_generated = await self._generate_signup_details_for_service(service_name)

            automation_result = None
            try:
                if not await self.browser_automator.setup_session(proxy_string=proxy_string, fingerprint_profile=fingerprint):
                    logger.error(f"[{service_name}] Failed to setup browser automator session.")
                    return None # Cannot proceed without session

                automation_result = await self.browser_automator.full_signup_and_extract(
                    service_name=service_name,
                    signup_url=service_automation_config["signup_url"],
                    form_interaction_plan=service_automation_config["form_interaction_plan"],
                    signup_details_generated=signup_details_generated,
                    success_indicator=service_automation_config["success_indicator"],
                    resource_extraction_rules=service_automation_config["resource_extraction_rules"],
                    captcha_config=service_automation_config.get("captcha_config"),
                    max_retries=service_automation_config.get("max_retries", 1)
                )
            except Exception as e:
                logger.error(f"BrowserAutomator execution raised an unhandled exception for {service_name}: {e}", exc_info=True)
                automation_result = {"status": "failed", "reason": f"Automator unhandled exception: {str(e)}"}
            finally:
                await self.browser_automator.close_session()
                if service_name_lower in self._active_automations: self._active_automations.remove(service_name_lower)


            if automation_result and automation_result.get("status") == "success":
                logger.info(f"Automated trial acquisition for {service_name} reported SUCCESS by automator.")
                extracted_resources = automation_result.get("extracted_resources", {})
                primary_key = extracted_resources.get("api_key") or extracted_resources.get("access_token") or extracted_resources.get("primary_resource_key")
                if not primary_key and extracted_resources: primary_key = next(iter(extracted_resources.values()), None)

                if not primary_key:
                    logger.error(f"Trial for {service_name} succeeded by automator, but NO primary key/token was extracted. Extracted: {extracted_resources}")
                    # Log this failure to Supabase for analysis
                    # self._log_failed_acquisition_attempt(...)
                    return None

                # --- Verification Step ---
                verified_ok = True # Assume OK if no verification step defined
                verification_config = service_automation_config.get("verification_step")
                if verification_config and primary_key:
                    logger.info(f"Attempting to verify acquired resource for {service_name}...")
                    # This is conceptual - verification needs a concrete implementation per service
                    # e.g., make a simple API call using the new key
                    # verified_ok = await self._execute_resource_verification(service_name, primary_key, verification_config)
                    logger.warning(f"Resource verification for {service_name} is CONCEPTUAL. Assuming success for now if key extracted.")
                    # if not verified_ok:
                    #     logger.error(f"Verification of acquired resource for {service_name} FAILED.")
                    #     # Log this failure to Supabase
                    #     return None
                
                if verified_ok:
                    logger.info(f"Acquired (and conceptually verified) resource for {service_name} is valid.")
                    creation_ts = datetime.now(timezone.utc)
                    trial_duration_days = int(service_automation_config.get("trial_duration_days", 7))
                    expiry_ts = creation_ts + timedelta(days=trial_duration_days)
                    resource_to_store = {
                        "service": service_name.lower(), "resource_type": "trial_account",
                        "resource_data": {
                            "key": primary_key, "username": signup_details_generated.get("email"),
                            "password": signup_details_generated.get("password"),
                            "signup_email": signup_details_generated.get("email"),
                            "all_extracted_resources": extracted_resources,
                            "cookies": automation_result.get("cookies")
                        },
                        "creation_timestamp": creation_ts.isoformat(), "expiry_timestamp": expiry_ts.isoformat(),
                        "status": "active",
                        "notes": f"Automated trial via {self.browser_automator.__class__.__name__}. Verified: {verified_ok}. Proxy: {proxy_string is not None}.",
                        "fingerprint_profile_summary": {"user_agent": fingerprint.get("user_agent"), "os": fingerprint.get("os")}
                    }
                    return resource_to_store
            else: # Automation failed
                reason = automation_result.get("reason", "Unknown failure") if automation_result else "Automator returned None"
                logger.error(f"Automated trial acquisition for {service_name} FAILED. Reason: {reason}")
                # Log this failure to Supabase for analysis
                # self._log_failed_acquisition_attempt(service_name, reason, signup_details_generated, fingerprint)
                return None
        # Ensure service is removed from active list if semaphore wait times out or other pre-automation error
        if service_name_lower in self._active_automations: self._active_automations.remove(service_name_lower)
        return None


    # _store_resource_in_supabase and _get_active_resource_from_supabase are crucial
    # Their implementation from the previous "Full Automation Orchestration" step was good.
    async def _store_resource_in_supabase(self, resource_dict: Dict[str, Any]) -> bool:
        # ... (Identical to previous correct implementation) ...
        if not self.supabase:
            logger.warning(f"Supabase not enabled. Cannot store resource for {resource_dict.get('service')}.")
            return False
        try:
            resource_dict_cleaned = json.loads(json.dumps(resource_dict, default=str)) 
            logger.info(f"Storing resource for '{resource_dict_cleaned.get('service')}' in Supabase.")
            response = await asyncio.to_thread(
                self.supabase.table(config.SUPABASE_RESOURCES_TABLE).insert(resource_dict_cleaned).execute
            )
            if hasattr(response, 'data') and response.data:
                logger.info(f"Successfully stored resource in Supabase. Record ID: {response.data[0].get('id')}")
                return True
            elif hasattr(response, 'status_code') and 200 <= response.status_code < 300:
                logger.info(f"Successfully stored resource in Supabase (status {response.status_code}).")
                return True
            else:
                logger.error(f"Supabase insert for resource failed or no data. Response: {response}")
                return False
        except Exception as e:
            logger.error(f"Error storing resource in Supabase: {e}", exc_info=True)
            return False

    async def _get_active_resource_from_supabase(self, service_name: str, resource_type: str) -> Optional[Dict[str, Any]]:
        # ... (Identical to previous correct implementation, checking expiry and status) ...
        if not self.supabase: return None
        current_time_iso = datetime.now(timezone.utc).isoformat()
        logger.debug(f"Querying Supabase for active '{resource_type}' for '{service_name}'.")
        try:
            query = (
                self.supabase.table(config.SUPABASE_RESOURCES_TABLE)
                .select("*")
                .eq("service", service_name.lower())
                .eq("resource_type", resource_type)
                .eq("status", "active")
                .gte("expiry_timestamp", current_time_iso)
                .order("expiry_timestamp", desc=True, nulls_first=True)
                .limit(1)
            )
            response = await asyncio.to_thread(query.execute)
            if response.data:
                resource = response.data[0]
                logger.info(f"Found active '{resource_type}' for '{service_name}' in Supabase (ID: {resource.get('id')}).")
                return resource
            return None
        except Exception as e:
            logger.error(f"Error querying Supabase for '{resource_type}' for '{service_name}': {e}", exc_info=True)
            return None

    async def _ensure_resource_via_automation(
        self,
        service_name: str,
        service_automation_config: Dict[str, Any] # Must contain all details for BrowserAutomator
        ) -> Optional[Dict[str, Any]]:
        """
        Core logic: checks Supabase for an active trial, if not found, attempts automated acquisition.
        Returns the full resource dictionary (from Supabase or the new attempt).
        """
        active_trial = await self._get_active_resource_from_supabase(service_name, "trial_account")
        if active_trial:
            logger.info(f"Active trial resource for '{service_name}' found in Supabase. Using it.")
            return active_trial

        logger.info(f"No active trial for '{service_name}'. Attempting automated acquisition.")
        new_trial_data_to_store = await self._attempt_and_verify_trial_acquisition(service_name, service_automation_config)

        if new_trial_data_to_store:
            if await self._store_resource_in_supabase(new_trial_data_to_store):
                logger.info(f"Automated trial for '{service_name}' acquired, verified (conceptually), and stored.")
                return new_trial_data_to_store # Or re-fetch for Supabase ID if critical
            else:
                logger.error(f"Failed to store new trial for '{service_name}'. Resource may be temporary.")
                new_trial_data_to_store["_persisted_in_supabase"] = False
                return new_trial_data_to_store # Return it anyway, but marked as not persisted
        logger.error(f"Automated trial acquisition for '{service_name}' did not yield a storable resource.")
        return None

    # --- Public Methods ---
    def get_proxy_string(self) -> Optional[str]:
        """Gets a proxy string using globally configured credentials from config.py."""
        if config.PROXY_USERNAME and config.PROXY_PASSWORD:
            return self.proxy_manager.get_proxy_string(config.PROXY_USERNAME, config.PROXY_PASSWORD)
        logger.debug("Global proxy username/password not configured in .env for ResourceManager.")
        return None

    async def get_api_key(self, service_name: str, service_automation_config: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Gets an API key for a service.
        Order of preference:
        1. Direct config (e.g., CLAY_API_KEY from .env for "clay.com").
        2. Active 'api_key' type resource from Supabase.
        3. Key from an active 'trial_account' resource in Supabase.
        4. If service_automation_config is provided, attempt automated trial acquisition.
        """
        service_name_lower = service_name.lower()
        logger.info(f"Requesting API key for service: '{service_name_lower}'. Automation config provided: {bool(service_automation_config)}")

        # 1. Direct config
        if service_name_lower == "clay.com" and self.direct_clay_api_key:
            logger.info("Using direct CLAY_API_KEY from .env.")
            return self.direct_clay_api_key
        # Add other service-specific direct config checks if any

        # 2. Active 'api_key' from Supabase
        api_key_resource = await self._get_active_resource_from_supabase(service_name_lower, "api_key")
        if api_key_resource and api_key_resource.get("resource_data", {}).get("key"):
            logger.info(f"Found active API key for '{service_name_lower}' (type: 'api_key') in Supabase.")
            return api_key_resource["resource_data"]["key"]

        # 3. Key from active 'trial_account' in Supabase
        trial_account_resource = await self._get_active_resource_from_supabase(service_name_lower, "trial_account")
        if trial_account_resource and trial_account_resource.get("resource_data", {}).get("key"):
            logger.info(f"Found API key within active 'trial_account' for '{service_name_lower}' in Supabase.")
            return trial_account_resource["resource_data"]["key"]
        
        # 4. Attempt automated trial acquisition if configured
        if service_automation_config and service_automation_config.get("signup_url"):
            logger.info(f"No readily available API key for '{service_name_lower}'. Attempting automated trial acquisition.")
            # _ensure_resource_via_automation handles checking existing before attempting new
            new_resource = await self._ensure_resource_via_automation(service_name_lower, service_automation_config)
            if new_resource and new_resource.get("resource_data", {}).get("key"):
                logger.info(f"Acquired API key for '{service_name_lower}' via automated trial.")
                return new_resource["resource_data"]["key"]
            else:
                logger.warning(f"Automated trial for '{service_name_lower}' attempted/checked, but no API key ('key') found/acquired.")
        
        logger.error(f"Failed to obtain API key for service: '{service_name_lower}'. All methods exhausted.")
        return None

    async def get_full_resource_bundle(self, service_name: str, service_automation_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Gets a comprehensive bundle: API key, credentials, proxy, fingerprint.
        Attempts resourceful acquisition if direct/stored resources are unavailable.
        The `service_automation_config` is crucial for services where trial acquisition is desired.
        """
        logger.info(f"Requesting full resource bundle for service: {service_name}")
        bundle: Dict[str, Any] = {"service": service_name, "api_key": None, "credentials": None, "proxy_string": None, "fingerprint_profile": None}
        service_name_lower = service_name.lower()

        # Get API Key (this now incorporates the trial acquisition logic if needed)
        bundle["api_key"] = await self.get_api_key(service_name_lower, service_automation_config)
        
        # Try to get credentials and associated fingerprint from the most relevant stored resource
        # This prioritizes trial_account if an API key was just acquired from it, or if it's the only source.
        # Otherwise, it checks for a specific 'credentials' type resource.
        
        # Check if a trial was just acquired or is the primary source for the key
        # This logic assumes get_api_key might have triggered _ensure_resource_via_automation
        # which returns the full resource dict. A cleaner way might be for get_api_key to return
        # the full resource dict itself, not just the key string.
        # For now, we re-query for the trial account if an API key was found.
        resource_for_creds_and_fp = None
        if bundle["api_key"]: # If we got a key, see if it came from a trial account we have stored
            trial_account_resource = await self._get_active_resource_from_supabase(service_name_lower, "trial_account")
            if trial_account_resource and trial_account_resource.get("resource_data", {}).get("key") == bundle["api_key"]:
                resource_for_creds_and_fp = trial_account_resource

        if not resource_for_creds_and_fp: # If key wasn't from a trial or no key, check 'credentials' type
            creds_resource = await self._get_active_resource_from_supabase(service_name_lower, "credentials")
            if creds_resource:
                resource_for_creds_and_fp = creds_resource
        
        # Extract credentials and fingerprint summary if a relevant resource was found
        associated_fingerprint_summary = None
        if resource_for_creds_and_fp and resource_for_creds_and_fp.get("resource_data"):
            rd = resource_for_creds_and_fp["resource_data"]
            if "username" in rd and "password" in rd:
                bundle["credentials"] = {"username": rd["username"], "password": rd["password"]}
            if resource_for_creds_and_fp.get("fingerprint_profile_summary"):
                 associated_fingerprint_summary = resource_for_creds_and_fp.get("fingerprint_profile_summary")
                 logger.info(f"Context for fingerprint generation will use summary from stored resource for {service_name}.")

        bundle["proxy_string"] = self.get_proxy_string()

        # Generate fingerprint, potentially influenced by context from associated_fingerprint_summary
        fp_os = associated_fingerprint_summary.get("os") if associated_fingerprint_summary else None
        fp_browser = associated_fingerprint_summary.get("browser") if associated_fingerprint_summary else None
        bundle["fingerprint_profile"] = await self.fingerprint_generator.generate_profile(
            role_context=f"Interaction with {service_name}", os_type=fp_os, browser_type=fp_browser
        )
        
        logger.info(f"Full resource bundle for '{service_name}'. API Key: {bool(bundle.get('api_key'))}, Creds: {bool(bundle.get('credentials'))}")
        return bundle

# --- Test function (conceptual, requires a concrete BrowserAutomator) ---
async def _test_resource_manager_with_automator():
    # This test requires a concrete implementation of BrowserAutomatorInterface.
    # For example, if you created MultiModalPlaywrightAutomator:
    # from core.automation.multimodal_playwright_automator import MultiModalPlaywrightAutomator
    # from core.services.llm_client import LLMClient

    print("--- Testing ResourceManager (with BrowserAutomator Orchestration) ---")
    
    # Initialize dependencies
    # llm = LLMClient() # Assuming OPENROUTER_API_KEY is set
    # fp_gen = FingerprintGenerator(llm_client=llm)
    # browser_automator_instance = MultiModalPlaywrightAutomator(llm_client=llm, headless=False) # Example
    
    # rm = ResourceManager(llm_client=llm, fingerprint_generator=fp_gen, browser_automator=browser_automator_instance)

    # Define the automation config for Clay.com (YOU MUST FILL THIS ACCURATELY)
    # This is the critical part that defines HOW the browser automator interacts with Clay's signup.
    clay_automation_config = {
        "signup_url": "https://app.clay.com/auth/signup", # VERIFY THIS URL
        "form_interaction_plan": [ # Sequence of actions for Playwright
            # Example: {"action": "fill", "selector": "input[name='email']", "value_key": "email"},
            #          {"action": "fill", "selector": "input[name='password']", "value_key": "password"},
            #          {"action": "click", "selector": "button[type='submit']"}
            # This plan needs to be meticulously created by inspecting Clay's signup page.
            # Using LLM vision within the automator can make selectors more dynamic.
        ],
        "success_indicator": { # How to tell if signup worked
            "type": "url_contains", "value": "/welcome" # Example: redirect to /welcome or /dashboard
            # Or: {"type": "text_present", "value": "Your account has been created!"}
        },
        "resource_extraction_rules": [ # How to get the API key after success
            # Example: {"type": "llm_vision_extraction",
            #           "prompt_template": "This screenshot shows the page after signup. Find the API key. It might be labeled 'API Key' or 'Access Token'. {screenshot_base64}",
            #           "resource_name": "api_key"},
            # Or: {"type": "element_text", "selector": "#user-api-key-display", "resource_name": "api_key"}
        ],
        "trial_duration_days": 7, # Typical trial length
        "max_retries": 1, # How many times to retry the whole signup flow
        "captcha_config": None # Add 2Captcha config here if needed by automator
        # "verification_step": { # Optional: How to verify the extracted key
        # "type": "api_call", "method": "GET", "url_template": "https://api.clay.com/v1/me", # VERIFY
        # "expected_response_code": 200, "response_json_path_check": "data.email" # Check if email exists in response
        # }
    }

    # print("\n1. Attempting to get Clay.com API Key (will try .env, Supabase, then full trial acquisition)...")
    # clay_key = await rm.get_api_key("clay.com", service_automation_config=clay_automation_config)
    # if clay_key:
    #     print(f"  SUCCESS: Clay API Key: {clay_key[:4]}...")
    # else:
    #     print("  FAILURE: Could not obtain Clay API Key via any method.")

    # print("\n2. Attempting to get full resource bundle for Clay.com...")
    # clay_bundle = await rm.get_full_resource_bundle("clay.com", service_automation_config=clay_automation_config)
    # print(f"  Clay Bundle: API Key: {bool(clay_bundle.get('api_key'))}, Creds: {bool(clay_bundle.get('credentials'))}, Proxy: {bool(clay_bundle.get('proxy_string'))}")
    # print(f"    Fingerprint UA: {clay_bundle.get('fingerprint_profile',{}).get('user_agent')}")

    # IMPORTANT: Close the browser automator's session if it was set up globally for the test
    # await browser_automator_instance.close_session()
    pass # Test function is illustrative

if __name__ == "__main__":
    # This test requires a concrete BrowserAutomatorInterface implementation (e.g., Playwright-based)
    # and accurate service_automation_config for any service you want to test trial acquisition for.
    # load_dotenv()
    # import asyncio
    # from core.automation.multimodal_playwright_automator import MultiModalPlaywrightAutomator # Example
    # from core.services.llm_client import LLMClient
    # async def run_actual_test():
    #     llm = LLMClient()
    #     fp_gen = FingerprintGenerator(llm)
    #     # IMPORTANT: headless=False for debugging, True for production
    #     playwright_automator = MultiModalPlaywrightAutomator(llm_client=llm, headless=True) 
    #     await _test_resource_manager_full_auto(browser_automator_instance=playwright_automator)
    # asyncio.run(run_actual_test())
    logger.info("ResourceManager (Full Automation Orchestration) defined. Test requires a concrete BrowserAutomator and detailed service_automation_configs.")